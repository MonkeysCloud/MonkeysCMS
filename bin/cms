#!/usr/bin/env php
<?php

declare(strict_types=1);

/**
 * MonkeysCMS CLI Tool
 * Usage: php bin/cms [command]
 */

use App\Core\Kernel;
use MonkeysLegion\Cli\CliKernel;
use MonkeysLegion\Cli\Console\Command;

if (php_sapi_name() !== 'cli') {
    exit;
}

require __DIR__ . '/../vendor/autoload.php';

// 1. Bootstrap Application
$rootDir = dirname(__DIR__);
// Define ML_BASE_PATH for helpers.php to resolve correctly
if (!defined('ML_BASE_PATH')) {
    define('ML_BASE_PATH', $rootDir);
}

$kernel = new Kernel($rootDir);
$kernel->bootstrap();
$container = $kernel->getContainer();

// 2. Discover Vendor Commands
// Scan vendor/monkeyscloud/*/src/Commands/*.php
$vendorCommands = [];
$vendorDirs = glob($rootDir . '/vendor/monkeyscloud/*/src/Commands');

if ($vendorDirs) {
    foreach ($vendorDirs as $dir) {
        $files = glob($dir . '/*Command.php');
        if (!$files) continue;

        foreach ($files as $file) {
            require_once $file;
            // Guess class name from file path
            // e.g. .../monkeyslegion-cache/src/Commands/CacheClearCommand.php
            // -> MonkeysLegion\Cache\Commands\CacheClearCommand
            
            // We can iterate declared classes to be safe, or parse the file.
            // Let's use declared classes check which is safer given we just required it.
        }
    }
}

// Find all Command subclasses currently declared (that are likely from vendors)
foreach (get_declared_classes() as $class) {
    if (str_starts_with($class, 'MonkeysLegion\\') && 
        str_contains($class, '\\Commands\\') && // Note: our cache commands are in \Commands\ namespace
        is_subclass_of($class, Command::class) &&
        !(new ReflectionClass($class))->isAbstract()
    ) {
        $vendorCommands[] = $class;
    }
}

// 3. Run CLI Kernel
// CliKernel automatically discovers App\Cli\Command and MonkeysLegion\Cli\Command
// We explicitly pass the additional vendor commands we found.

try {
    $cli = new CliKernel($container, $vendorCommands);
    exit($cli->run($argv));
} catch (\Throwable $e) {
    fwrite(STDERR, "Fatal Error: " . $e->getMessage() . "\n");
    exit(1);
}
